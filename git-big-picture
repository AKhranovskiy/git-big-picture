#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (C) 2010 Sebastian Pipping <sebastian@pipping.org>
# Licensed under GPL v3 or later
#
import subprocess
import re

branch_extractor = re.compile('^[* ] ([^ ]+)(?: -> .+)?$')
sha1_pattern = re.compile('[0-9a-fA-F]{40}')


def loop(l):
	"""Generator looping over a potentially changing
		iteratable input, e.g. a set"""
	while l:
		res = list(l)
		for r in res:
			if r not in l:
				continue
			yield r

def get_command_output(command_list):
	p = subprocess.Popen(command_list, stdout=subprocess.PIPE)
	p.wait()
	return p.stdout.read()

def get_branch_names():
	branch_names = []
	output = get_command_output(['git', 'branch', '-a'])
	for line in output.split('\n'):
		m = branch_extractor.match(line)
		if m is not None:
			branch_names.append(m.group(1))
	return branch_names

def get_tag_names():
	tag_names = []
	output = get_command_output(['git', 'tag', '-l'])
	for line in output.split('\n'):
		if line == '':
			continue
		tag_names.append(line)
	return tag_names

def ref_to_sha1(ref):
	output = get_command_output(['git', 'rev-parse', ref])
	for line in output.split('\n'):
		return line

def branch_to_sha1(branch_name):
	if branch_name.startswith('remotes/'):
		ref = branch_name
	else:
		ref = 'refs/heads/%s' % branch_name
	return ref_to_sha1(ref)

def tag_to_sha1(tag_name):
	return ref_to_sha1('refs/tags/%s' % tag_name)


def get_parent_map():
	parents = {}
	p = subprocess.Popen(['git', 'rev-list', '--all', '--parents'], stdout=subprocess.PIPE)
	output = p.communicate()[0]
	for line in output.split('\n'):
		sha_ones = [e.group(0) for e in re.finditer(sha1_pattern, line)]
		count = len(sha_ones)
		if count > 1:
			parents[sha_ones[0]] = set(sha_ones[1:])
		elif count == 1:
			parents[sha_ones[0]] = set()
	return parents


def get_label_dict():
	labels = {}

	for b in get_branch_names():
		ref = branch_to_sha1(b)
		if ref not in labels:
			labels[ref] = set()
		labels[ref].add(b)

	for t in get_tag_names():
		ref = tag_to_sha1(t)
		if ref not in labels:
			labels[ref] = set()
		labels[ref].add(t)

	return labels


class CommitGraph(object):
	def __init__(self, parent_map, label_dict):
		self.parents = parent_map
		self.labels = label_dict

		self.children = {}
		self._calculate_child_mapping()
		self._verify_child_mapping()

	def _calculate_child_mapping(self):
		for sha_one, parent_sha_ones in self.parents.items():
			for p in parent_sha_ones:
				if p not in self.children:
					self.children[p] = set()
				self.children[p].add(sha_one)
			if sha_one not in self.children:
				self.children[sha_one] = set()

	def _verify_child_mapping(self):
		for sha_one, pars in self.parents.items():
			for p in pars:
				for c in self.children[p]:
					assert(p in self.parents[c])
		for sha_one, chs in self.children.items():
			for c in chs:
				for p in self.parents[c]:
					assert(c in self.children[p])

	def _optimize_linear_runs_away(self):
		todo_list = self.parents.keys()
		black_list = set()
		for sha_one in todo_list:
			if sha_one in black_list:
				continue

			path = [sha_one, ]
			current = sha_one
			while True:
				if len(self.parents[current]) != 1:
					break
				parent = list(self.parents[current])[0]
				if len(self.children[parent]) != 1:
					break
				path.append(parent)
				if parent in self.labels:
					break
				current = parent

			if len(path) > 2:
				edge_child = path[0]
				edge_parent = path[-1]

				self.parents[edge_child].remove(path[1])
				self.parents[edge_child].add(edge_parent)
				self.children[edge_parent].remove(path[-2])
				self.children[edge_parent].add(edge_child)
				for index, i in enumerate(path[1:-1]):
					black_list.add(i)
		for sha_one in black_list:
			del self.parents[sha_one]
			del self.children[sha_one]

	def _optimize_merge_branch_fits_away(self):
		todo_list = self.parents.keys()
		black_list = set()
		for sha_one in todo_list:
			if sha_one in black_list:
				continue

			# 1/3 Run up the DAG as far as we can
			up_runners = set([sha_one, ])
			## visits = dict([(sha_one, len(children(sha_one))),])
			_children = dict()
			_parents = dict()
			_sources = set()
			for run_start in loop(up_runners):
				current = run_start
				while True:
					if current not in _parents:
						_parents[current] = set()
					if current not in _children:
						_children[current] = set()

					if current in self.labels \
							and current != sha_one:
						up_runners.remove(run_start)
						_sources.add(current)
						break
					if not self.parents[current]:
						up_runners.remove(run_start)
						_sources.add(current)
						break
					if current != sha_one \
							and len(_children[current]) \
							< len(self.children[current]):
						up_runners.remove(run_start)
						_sources.add(current)
						break

					parent_list = list(self.parents[current])
					for p in parent_list:
						if p not in _children:
							_children[p] = set()
						_children[p].add(current)
						_parents[current].add(p)

					next, other_parents = parent_list[0], parent_list[1:]
					for p in other_parents:
						up_runners.add(p)
					current = next

			# Remove complete branch points from sources
			# as we completeness allowed us running further up the DAG
			for s in list(_sources):
				if len(_children[s]) == len(self.children[s]):
					_sources.remove(s)

			# 2/3 Run down the temp DAG cutting edges where a merge
			# cannot be complete all from this sources
			_cut_points = set()
			for s in _sources:
				down_runners = set([s,])
				_up_pass_parents = dict()
				for run_start in loop(down_runners):
					current = run_start
					while True:
						if not _children.get(current, []):
							down_runners.remove(run_start)
							break

						child_list = list(_children[current])
						for ch in child_list:
							if ch not in _up_pass_parents:
								_up_pass_parents[ch] = set()
							_up_pass_parents[ch].add(current)

						next, other_children = child_list[0], child_list[1:]
						for p in other_children:
							down_runners.add(p)
						current = next

				for k, v in _up_pass_parents.items():
					diff = _parents[k] - _up_pass_parents[k]
					if diff:
						_cut_points.add(k)

			## # One source, one sink
			source_sink_pairs = set()
			for k, v in _parents.items():
				if k not in _cut_points and v:
					# Not a source
					continue

				# Find sink
				current = k
				while True:
					child_list = list(_children[current])
					if not child_list or (current in _cut_points and k != current):
						# Sink found
						if k != current:
							source_sink_pairs.add((k, current))
						break
					current = child_list[0]
			sources = set(e[0] for e in source_sink_pairs)
			sinks = set(e[1] for e in source_sink_pairs)
			to_delete = set(_parents.keys()) - sources.union(sinks)
			map(black_list.add, to_delete)

			for d in to_delete:
				assert(d not in self.labels)

				for p in self.parents[d]:
					# if d in self.children[p]:
					self.children[p].remove(d)
					for ch in self.children[d]:
						self.children[p].add(ch)
						self.parents[ch].add(p)
				for ch in self.children[d]:
					#if d in self.parents[ch]:
					self.parents[ch].remove(d)
					for p in self.parents[d]:
						self.parents[ch].add(p)
						self.children[p].add(ch)
				# self.parents[d].clear()
				# self.children[d].clear()
				del self.parents[d]
				del self.children[d]

		self._verify_child_mapping()

	def _optimize_non_labels(self):
		todo_list = self.parents.keys()
		black_list = set()
		for sha_one in todo_list:
			if sha_one in black_list:
				continue

			# 1/3 Run up the DAG as far as we can
			up_runners = set([sha_one, ])
			## visits = dict([(sha_one, len(children(sha_one))),])
			_children = dict()
			_parents = dict()
			_sources = set()
			for run_start in loop(up_runners):
				current = run_start
				while True:
					if current not in _parents:
						_parents[current] = set()
					if current not in _children:
						_children[current] = set()

					if current in self.labels \
							and current != sha_one:
						up_runners.remove(run_start)
						_sources.add(current)
						break
					if not self.parents[current]:
						up_runners.remove(run_start)
						_sources.add(current)
						break
					if current != sha_one \
							and len(_children[current]) \
							< len(self.children[current]):
						up_runners.remove(run_start)
						_sources.add(current)
						break

					parent_list = list(self.parents[current])
					for p in parent_list:
						if p not in _children:
							_children[p] = set()
						_children[p].add(current)
						_parents[current].add(p)

					next, other_parents = parent_list[0], parent_list[1:]
					for p in other_parents:
						up_runners.add(p)
					current = next		

			# Remove complete branch points from sources
			# as we completeness allowed us running further up the DAG
			for s in list(_sources):
				if s in self.labels or not self.parents[s]:
					continue
				if len(_children[s]) == len(self.children[s]):
					_sources.remove(s)

			
			# print '_parents.keys()', '\n'.join(_parents.keys())
			# print '_sources', '\n'.join(_sources)
			# print 'sha_one', '\n'.join([sha_one, ])
			to_delete = (set(_parents.keys()) - _sources) - set([sha_one, ])
			# print 'to_delete', '\n'.join(to_delete)

			if sha_one not in self.labels: # and len(self.parents[sha_one]) == 1:
				to_delete.add(sha_one)

			for d in to_delete:
				assert(d not in self.labels)

				for p in self.parents[d]:
					# if d in self.children[p]:
					self.children[p].remove(d)
					for ch in self.children[d]:
						self.children[p].add(ch)
						self.parents[ch].add(p)
				for ch in self.children[d]:
					#if d in self.parents[ch]:
					self.parents[ch].remove(d)
					for p in self.parents[d]:
						self.parents[ch].add(p)
						self.children[p].add(ch)
				# self.parents[d].clear()
				# self.children[d].clear()
				del self.parents[d]
				del self.children[d]
				
				black_list.add(d)

		self._verify_child_mapping()

	def _print_dot_file(self):
		print 'digraph {'
		for k, v in self.labels.items():
			if k not in self.parents:
				continue
			print '\t"%(ref)s"[label="%(label)s", color=lightblue2, style=filled];' % {
				'ref':k,
				'label':'\\n'.join(v)}
		for child, self.parents in self.parents.items():
			for p in self.parents:
				print '\t"%(source)s" -> "%(target)s";' % {'source':child, 'target':p}
		print '}'


if __name__ == '__main__':
	graph = CommitGraph(get_parent_map(), get_label_dict())
	# graph._optimize_linear_runs_away()
	# graph._optimize_merge_branch_fits_away()
	graph._optimize_non_labels()
	graph._print_dot_file()
