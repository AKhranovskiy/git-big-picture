#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (C) 2010 Sebastian Pipping <sebastian@pipping.org>
# Copyright (C) 2010 Julius Plenz <julius@plenz.com>
# Licensed under GPL v3 or later
#
import subprocess
import re

branch_extractor = re.compile('^[* ] ([^ ]+)(?: -> .+)?$')
sha1_pattern = re.compile('[0-9a-fA-F]{40}')
git_env = None


def loop(l):
	"""Generator looping over a potentially changing
		iteratable input, e.g. a set"""
	while l:
		res = list(l)
		for r in res:
			if r not in l:
				continue
			yield r

def get_command_output(command_list):
	p = subprocess.Popen(command_list, stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=git_env)
	p.wait()
	if p.returncode:
		raise Exception('Return code %d from command "%s"' \
			% (p.returncode, ' '.join(command_list)))
	return p.stdout.read()

def get_branch_names(is_local):
	branch_names = []
	if is_local:
		command_list = ['git', 'branch']
	else:
		command_list = ['git', 'branch', '-r']
	output = get_command_output(command_list)
	for line in output.split('\n'):
		m = branch_extractor.match(line)
		if m is not None:
			branch_names.append(m.group(1))
	return branch_names

def get_tag_names():
	tag_names = []
	output = get_command_output(['git', 'tag', '-l'])
	for line in output.split('\n'):
		if line == '':
			continue
		tag_names.append(line)
	return tag_names

def ref_to_sha1(ref):
	output = get_command_output(['git', 'rev-parse', ref])
	for line in output.split('\n'):
		return line

def branch_to_sha1(branch_name, is_local):
	if is_local:
		ref = 'refs/heads/%s' % branch_name
	else:
		ref = 'refs/remotes/%s' % branch_name
	return ref_to_sha1(ref)

def tag_to_sha1(tag_name):
	return ref_to_sha1('refs/tags/%s^{commit}' % tag_name)


def get_parent_map():
	parents = {}
	p = subprocess.Popen(['git', 'rev-list', '--all', '--parents'], stdout=subprocess.PIPE, env=git_env)
	output = p.communicate()[0]
	for line in output.split('\n'):
		sha_ones = [e.group(0) for e in re.finditer(sha1_pattern, line)]
		count = len(sha_ones)
		if count > 1:
			parents[sha_ones[0]] = set(sha_ones[1:])
		elif count == 1:
			parents[sha_ones[0]] = set()
	return parents


def get_branch_dict():
	labels = {}
	for is_local in (True, False):
		for b in get_branch_names(is_local):
			ref = branch_to_sha1(b, is_local)
			if ref not in labels:
				labels[ref] = set()
			labels[ref].add(b)
	return labels


def get_tag_dict():
	labels = {}
	for t in get_tag_names():
		try:
			ref = tag_to_sha1(t)
		except:
			# Blob-tags get us here (e.g. with git.git)
			continue
		if ref not in labels:
			labels[ref] = set()
		labels[ref].add(t)
	return labels


class CommitGraph(object):
	def __init__(self, parent_map, branch_dict, tag_dict):
		self.parents = parent_map
		self.branches = branch_dict
		self.tags = tag_dict

		self.children = {}
		self._calculate_child_mapping()
		self._verify_child_mapping()

	def _has_label(self, sha_one):
		return sha_one in self.branches \
			or sha_one in self.tags

	def _calculate_child_mapping(self):
		for sha_one, parent_sha_ones in self.parents.items():
			for p in parent_sha_ones:
				if p not in self.children:
					self.children[p] = set()
				self.children[p].add(sha_one)
			if sha_one not in self.children:
				self.children[sha_one] = set()

	def _verify_child_mapping(self):
		for sha_one, pars in self.parents.items():
			for p in pars:
				for c in self.children[p]:
					assert(p in self.parents[c])
		for sha_one, chs in self.children.items():
			for c in chs:
				for p in self.parents[c]:
					assert(c in self.children[p])

	def _optimize_linear_runs_away(self):
		todo_list = self.parents.keys()
		black_list = set()
		for sha_one in todo_list:
			if sha_one in black_list:
				continue

			path = [sha_one, ]
			current = sha_one
			while True:
				if len(self.parents[current]) != 1:
					break
				parent = list(self.parents[current])[0]
				if len(self.children[parent]) != 1:
					break
				path.append(parent)
				if self._has_label(parent):
					break
				current = parent

			if len(path) > 2:
				edge_child = path[0]
				edge_parent = path[-1]

				self.parents[edge_child].remove(path[1])
				self.parents[edge_child].add(edge_parent)
				self.children[edge_parent].remove(path[-2])
				self.children[edge_parent].add(edge_child)
				for index, i in enumerate(path[1:-1]):
					black_list.add(i)
		for sha_one in black_list:
			del self.parents[sha_one]
			del self.children[sha_one]

	def _optimize_merge_branch_fits_away(self):
		todo_list = self.parents.keys()
		black_list = set()
		for sha_one in todo_list:
			if sha_one in black_list:
				continue

			# 1/3 Run up the DAG as far as we can
			up_runners = set([sha_one, ])
			_children = dict()
			_parents = dict()
			_sources = set()
			for run_start in loop(up_runners):
				current = run_start
				while True:
					if current not in _parents:
						_parents[current] = set()
					if current not in _children:
						_children[current] = set()

					if self._has_label(current) \
							and current != sha_one:
						up_runners.remove(run_start)
						_sources.add(current)
						break
					if not self.parents[current]:
						up_runners.remove(run_start)
						_sources.add(current)
						break
					if current != sha_one \
							and len(_children[current]) \
							< len(self.children[current]):
						up_runners.remove(run_start)
						_sources.add(current)
						break

					parent_list = list(self.parents[current])
					for p in parent_list:
						if p not in _children:
							_children[p] = set()
						_children[p].add(current)
						_parents[current].add(p)

					next, other_parents = parent_list[0], parent_list[1:]
					for p in other_parents:
						up_runners.add(p)
					current = next

			# Remove complete branch points from sources
			# as we completeness allowed us running further up the DAG
			for s in list(_sources):
				if len(_children[s]) == len(self.children[s]):
					_sources.remove(s)

			# 2/3 Run down the temp DAG cutting edges where a merge
			# cannot be complete all from this sources
			_cut_points = set()
			for s in _sources:
				down_runners = set([s,])
				_up_pass_parents = dict()
				for run_start in loop(down_runners):
					current = run_start
					while True:
						if not _children.get(current, []):
							down_runners.remove(run_start)
							break

						child_list = list(_children[current])
						for ch in child_list:
							if ch not in _up_pass_parents:
								_up_pass_parents[ch] = set()
							_up_pass_parents[ch].add(current)

						next, other_children = child_list[0], child_list[1:]
						for p in other_children:
							down_runners.add(p)
						current = next

				for k, v in _up_pass_parents.items():
					diff = _parents[k] - _up_pass_parents[k]
					if diff:
						_cut_points.add(k)

			## # One source, one sink
			source_sink_pairs = set()
			for k, v in _parents.items():
				if k not in _cut_points and v:
					# Not a source
					continue

				# Find sink
				current = k
				while True:
					child_list = list(_children[current])
					if not child_list or (current in _cut_points and k != current):
						# Sink found
						if k != current:
							source_sink_pairs.add((k, current))
						break
					current = child_list[0]
			sources = set(e[0] for e in source_sink_pairs)
			sinks = set(e[1] for e in source_sink_pairs)
			to_delete = set(_parents.keys()) - sources.union(sinks)
			map(black_list.add, to_delete)

			for d in to_delete:
				assert(not self._has_label(d))

				for p in self.parents[d]:
					self.children[p].remove(d)
					for ch in self.children[d]:
						self.children[p].add(ch)
						self.parents[ch].add(p)
				for ch in self.children[d]:
					self.parents[ch].remove(d)
					for p in self.parents[d]:
						self.parents[ch].add(p)
						self.children[p].add(ch)
				del self.parents[d]
				del self.children[d]

		self._verify_child_mapping()

	def _optimize_non_labels(self):
		todo_list = self.parents.keys()
		black_list = set()
		for sha_one in todo_list:
			if sha_one in black_list:
				continue

			# 1/3 Run up the DAG as far as we can
			up_runners = set([sha_one, ])
			_children = dict()
			_parents = dict()
			_sources = set()
			for run_start in loop(up_runners):
				current = run_start
				while True:
					if current not in _parents:
						_parents[current] = set()
					if current not in _children:
						_children[current] = set()

					if self._has_label(current) \
							and current != sha_one:
						up_runners.remove(run_start)
						_sources.add(current)
						break
					if not self.parents[current]:
						up_runners.remove(run_start)
						_sources.add(current)
						break
					if current != sha_one \
							and len(_children[current]) \
							< len(self.children[current]):
						up_runners.remove(run_start)
						_sources.add(current)
						break

					parent_list = list(self.parents[current])
					for p in parent_list:
						if p not in _children:
							_children[p] = set()
						_children[p].add(current)
						_parents[current].add(p)

					next, other_parents = parent_list[0], parent_list[1:]
					for p in other_parents:
						up_runners.add(p)
					current = next		

			# Remove complete branch points from sources
			# as we completeness allowed us running further up the DAG
			for s in list(_sources):
				if self._has_label(s) or not self.parents[s]:
					continue
				if len(_children[s]) == len(self.children[s]):
					_sources.remove(s)

			
			to_delete = (set(_parents.keys()) - _sources) - set([sha_one, ])

			if not self._has_label(sha_one):
				to_delete.add(sha_one)

			for d in to_delete:
				assert(not self._has_label(d))

				for p in self.parents[d]:
					self.children[p].remove(d)
					for ch in self.children[d]:
						self.children[p].add(ch)
						self.parents[ch].add(p)
				for ch in self.children[d]:
					self.parents[ch].remove(d)
					for p in self.parents[d]:
						self.parents[ch].add(p)
						self.children[p].add(ch)
				del self.parents[d]
				del self.children[d]
				
				black_list.add(d)

		# Cut transitive redundant edges
		for sha_one in self.parents.keys():
			multi_child_parents = set(e for e in self.parents[sha_one] if len(self.children[e]) > 1)
			if len(self.parents[sha_one]) < 2:
				continue
			for p in multi_child_parents:
				other_parents = self.parents[sha_one] - set([p, ])
				down_runners = set([p, ])
				for run_start in loop(down_runners):
					current = run_start
					while True:
						if current == sha_one:
							down_runners.remove(run_start)
							break
						elif current in other_parents:
							self.parents[sha_one].remove(p)
							self.children[p].remove(sha_one)
							down_runners.clear()
							break

						child_list = list(self.children[current])
						l = len(child_list)
						if l > 1:
							next, other_children = child_list[0], child_list[1:]
						elif l == 1:
							next, other_children = child_list[0], list()
						else:
							down_runners.remove(run_start)
							break

						for c in other_children:
							down_runners.add(c)
						current = next

		self._verify_child_mapping()

	def _print_dot_file(self):
		def label_gen():
			keys = set(self.branches.keys()).union(set(self.tags.keys()))
			for k in keys:
				labels = []
				case = 0
				if k in self.tags:
					case = case + 1
					map(labels.append, sorted(self.tags[k]))
				if k in self.branches:
					case = case + 2
					map(labels.append, sorted(self.branches[k]))
				# http://www.graphviz.org/doc/info/colors.html
				color = "/pastel13/%d" % case
				yield (k, labels, color)
					
		print 'digraph {'
		for sha_one, labels, color in label_gen():
			print '\t"%(ref)s"[label="%(label)s", color="%(color)s", style=filled];' % {
				'ref':sha_one,
				'label':'\\n'.join(labels),
				'color':color}
		for child, self.parents in self.parents.items():
			for p in self.parents:
				print '\t"%(source)s" -> "%(target)s";' % {'source':child, 'target':p}
		print '}'


if __name__ == '__main__':
	from optparse import OptionParser
	parser = OptionParser()
	opts, args = parser.parse_args()
	if len(args) == 1:
		# check whether the argument is a valid git directory
		p = subprocess.Popen(['git', 'rev-parse', '--git-dir'],
			stdout=subprocess.PIPE, stderr=subprocess.PIPE, env={'GIT_DIR': args[0]})
		p.wait()
		if p.returncode:
			import sys
			sys.stderr.write('Fatal: Does not appear to be a .git directory: %s.\n' % args[0])
			sys.exit(1)
		else:
			git_env = {'GIT_DIR': args[0]}
	graph = CommitGraph(get_parent_map(), get_branch_dict(), get_tag_dict())
	# graph._optimize_linear_runs_away()
	# graph._optimize_merge_branch_fits_away()
	graph._optimize_non_labels()
	graph._print_dot_file()
