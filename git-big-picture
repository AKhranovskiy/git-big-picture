#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (C) 2010 Sebastian Pipping <sebastian@pipping.org>
# Copyright (C) 2010 Julius Plenz <julius@plenz.com>
# Copyright (C) 2010 Valentin Haenel <valentin.haenel@gmx.de>
# Licensed under GPL v3 or later
#
import subprocess
import re

VERSION = '0.8'

branch_extractor = re.compile('^[* ] ([^ ]+)(?: -> .+)?$')
sha1_pattern = re.compile('[0-9a-fA-F]{40}')
git_env = None


def loop(l):
	"""Generator looping over a potentially changing
		iteratable input, e.g. a set"""
	while l:
		res = list(l)
		for r in res:
			if r not in l:
				continue
			yield r

def get_command_output(command_list):
	p = subprocess.Popen(command_list, stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=git_env)
	p.wait()
	if p.returncode:
		raise Exception('Return code %d from command "%s"' \
			% (p.returncode, ' '.join(command_list)))
	return p.stdout.read()

def get_branch_names(is_local):
	if is_local:
		command_list = ['git', 'branch']
	else:
		command_list = ['git', 'branch', '-r']
	output = get_command_output(command_list)
	return convert_raw_branch_list(output)

def convert_raw_branch_list(branch_list):
	branch_names = []
	for line in branch_list.split('\n'):
		m = branch_extractor.match(line)
		if m is not None:
			branch_names.append(m.group(1))
	return branch_names

def get_tag_names():
	output = get_command_output(['git', 'tag', '-l'])
	return convert_raw_tag_list(output)

def convert_raw_tag_list(tag_list):
	tag_names = []
	for line in tag_list.split('\n'):
		if line == '':
			continue
		tag_names.append(line)
	return tag_names

def ref_to_sha1(ref):
	output = get_command_output(['git', 'rev-parse', ref])
	for line in output.split('\n'):
		return line

def branch_to_sha1(branch_name, is_local):
	if is_local:
		ref = 'refs/heads/%s' % branch_name
	else:
		ref = 'refs/remotes/%s' % branch_name
	return ref_to_sha1(ref)

def tag_to_sha1(tag_name):
	return ref_to_sha1('refs/tags/%s^{commit}' % tag_name)


def get_parent_map():
	parents = {}
	p = subprocess.Popen(['git', 'rev-list', '--all', '--parents'], stdout=subprocess.PIPE, env=git_env)
	output = p.communicate()[0]
	for line in output.split('\n'):
		sha_ones = [e.group(0) for e in re.finditer(sha1_pattern, line)]
		count = len(sha_ones)
		if count > 1:
			parents[sha_ones[0]] = set(sha_ones[1:])
		elif count == 1:
			parents[sha_ones[0]] = set()
	return parents


def get_branch_dict():
	labels = {}
	for is_local in (True, False):
		for b in get_branch_names(is_local):
			ref = branch_to_sha1(b, is_local)
			if ref not in labels:
				labels[ref] = set()
			labels[ref].add(b)
	return labels


def get_tag_dict():
	labels = {}
	for t in get_tag_names():
		try:
			ref = tag_to_sha1(t)
		except:
			# Blob-tags get us here (e.g. with git.git)
			continue
		if ref not in labels:
			labels[ref] = set()
		labels[ref].add(t)
	return labels


class CommitGraph(object):
	def __init__(self, parent_map, branch_dict, tag_dict):
		self.parents = parent_map
		self.branches = branch_dict
		self.tags = tag_dict

		self.children = {}
		self._calculate_child_mapping()
		self._verify_child_mapping()

	def _has_label(self, sha_one):
		return sha_one in self.branches \
			or sha_one in self.tags

	def _calculate_child_mapping(self):
		for sha_one, parent_sha_ones in self.parents.items():
			for p in parent_sha_ones:
				if p not in self.children:
					self.children[p] = set()
				self.children[p].add(sha_one)
			if sha_one not in self.children:
				self.children[sha_one] = set()

	def _verify_child_mapping(self):
		for sha_one, pars in self.parents.items():
			for p in pars:
				for c in self.children[p]:
					assert(p in self.parents[c])
		for sha_one, chs in self.children.items():
			for c in chs:
				for p in self.parents[c]:
					assert(c in self.children[p])

	def _optimize_linear_runs_away(self):
		todo_list = self.parents.keys()
		black_list = set()
		for sha_one in todo_list:
			if sha_one in black_list:
				continue

			path = [sha_one, ]
			current = sha_one
			while True:
				if len(self.parents[current]) != 1:
					break
				parent = list(self.parents[current])[0]
				if len(self.children[parent]) != 1:
					break
				path.append(parent)
				if self._has_label(parent):
					break
				current = parent

			if len(path) > 2:
				edge_child = path[0]
				edge_parent = path[-1]

				self.parents[edge_child].remove(path[1])
				self.parents[edge_child].add(edge_parent)
				self.children[edge_parent].remove(path[-2])
				self.children[edge_parent].add(edge_child)
				for index, i in enumerate(path[1:-1]):
					black_list.add(i)
		for sha_one in black_list:
			del self.parents[sha_one]
			del self.children[sha_one]

	def _optimize_merge_branch_fits_away(self):
		todo_list = self.parents.keys()
		black_list = set()
		for sha_one in todo_list:
			if sha_one in black_list:
				continue

			# 1/3 Run up the DAG as far as we can
			up_runners = set([sha_one, ])
			_children = dict()
			_parents = dict()
			_sources = set()
			for run_start in loop(up_runners):
				current = run_start
				while True:
					if current not in _parents:
						_parents[current] = set()
					if current not in _children:
						_children[current] = set()

					if self._has_label(current) \
							and current != sha_one:
						up_runners.remove(run_start)
						_sources.add(current)
						break
					if not self.parents[current]:
						up_runners.remove(run_start)
						_sources.add(current)
						break
					if current != sha_one \
							and len(_children[current]) \
							< len(self.children[current]):
						up_runners.remove(run_start)
						_sources.add(current)
						break

					parent_list = list(self.parents[current])
					for p in parent_list:
						if p not in _children:
							_children[p] = set()
						_children[p].add(current)
						_parents[current].add(p)

					next, other_parents = parent_list[0], parent_list[1:]
					for p in other_parents:
						up_runners.add(p)
					current = next

			# Remove complete branch points from sources
			# as we completeness allowed us running further up the DAG
			for s in list(_sources):
				if len(_children[s]) == len(self.children[s]):
					_sources.remove(s)

			# 2/3 Run down the temp DAG cutting edges where a merge
			# cannot be complete all from this sources
			_cut_points = set()
			for s in _sources:
				down_runners = set([s,])
				_up_pass_parents = dict()
				for run_start in loop(down_runners):
					current = run_start
					while True:
						if not _children.get(current, []):
							down_runners.remove(run_start)
							break

						child_list = list(_children[current])
						for ch in child_list:
							if ch not in _up_pass_parents:
								_up_pass_parents[ch] = set()
							_up_pass_parents[ch].add(current)

						next, other_children = child_list[0], child_list[1:]
						for p in other_children:
							down_runners.add(p)
						current = next

				for k, v in _up_pass_parents.items():
					diff = _parents[k] - _up_pass_parents[k]
					if diff:
						_cut_points.add(k)

			## # One source, one sink
			source_sink_pairs = set()
			for k, v in _parents.items():
				if k not in _cut_points and v:
					# Not a source
					continue

				# Find sink
				current = k
				while True:
					child_list = list(_children[current])
					if not child_list or (current in _cut_points and k != current):
						# Sink found
						if k != current:
							source_sink_pairs.add((k, current))
						break
					current = child_list[0]
			sources = set(e[0] for e in source_sink_pairs)
			sinks = set(e[1] for e in source_sink_pairs)
			to_delete = set(_parents.keys()) - sources.union(sinks)
			map(black_list.add, to_delete)

			for d in to_delete:
				assert(not self._has_label(d))

				for p in self.parents[d]:
					self.children[p].remove(d)
					for ch in self.children[d]:
						self.children[p].add(ch)
						self.parents[ch].add(p)
				for ch in self.children[d]:
					self.parents[ch].remove(d)
					for p in self.parents[d]:
						self.parents[ch].add(p)
						self.children[p].add(ch)
				del self.parents[d]
				del self.children[d]

		self._verify_child_mapping()

	def _optimize_non_labels(self):
		todo_list = self.parents.keys()
		black_list = set()
		for sha_one in todo_list:
			if sha_one in black_list:
				continue

			# 1/3 Run up the DAG as far as we can
			up_runners = set([sha_one, ])
			_children = dict()
			_parents = dict()
			_sources = set()
			for run_start in loop(up_runners):
				current = run_start
				while True:
					if current not in _parents:
						_parents[current] = set()
					if current not in _children:
						_children[current] = set()

					if self._has_label(current) \
							and current != sha_one:
						up_runners.remove(run_start)
						_sources.add(current)
						break
					if not self.parents[current]:
						up_runners.remove(run_start)
						_sources.add(current)
						break
					if current != sha_one \
							and len(_children[current]) \
							< len(self.children[current]):
						up_runners.remove(run_start)
						_sources.add(current)
						break

					parent_list = list(self.parents[current])
					for p in parent_list:
						if p not in _children:
							_children[p] = set()
						_children[p].add(current)
						_parents[current].add(p)

					next, other_parents = parent_list[0], parent_list[1:]
					for p in other_parents:
						up_runners.add(p)
					current = next		

			# Remove complete branch points from sources
			# as we completeness allowed us running further up the DAG
			for s in list(_sources):
				if self._has_label(s) or not self.parents[s]:
					continue
				if len(_children[s]) == len(self.children[s]):
					_sources.remove(s)

			
			to_delete = (set(_parents.keys()) - _sources) - set([sha_one, ])

			if not self._has_label(sha_one):
				to_delete.add(sha_one)

			for d in to_delete:
				assert(not self._has_label(d))

				for p in self.parents[d]:
					self.children[p].remove(d)
					for ch in self.children[d]:
						self.children[p].add(ch)
						self.parents[ch].add(p)
				for ch in self.children[d]:
					self.parents[ch].remove(d)
					for p in self.parents[d]:
						self.parents[ch].add(p)
						self.children[p].add(ch)
				del self.parents[d]
				del self.children[d]
				
				black_list.add(d)

		# Cut transitive redundant edges
		for sha_one in self.parents.keys():
			multi_child_parents = set(e for e in self.parents[sha_one] if len(self.children[e]) > 1)
			if len(self.parents[sha_one]) < 2:
				continue
			for p in multi_child_parents:
				other_parents = self.parents[sha_one] - set([p, ])
				down_runners = set([p, ])
				for run_start in loop(down_runners):
					current = run_start
					while True:
						if current == sha_one:
							down_runners.remove(run_start)
							break
						elif current in other_parents:
							self.parents[sha_one].remove(p)
							self.children[p].remove(sha_one)
							down_runners.clear()
							break

						child_list = list(self.children[current])
						l = len(child_list)
						if l > 1:
							next, other_children = child_list[0], child_list[1:]
						elif l == 1:
							next, other_children = child_list[0], list()
						else:
							down_runners.remove(run_start)
							break

						for c in other_children:
							down_runners.add(c)
						current = next

		self._verify_child_mapping()

	def _remove_non_labels(self):
		""" Generate the subgraph of the Git commit graph that contains only
		tags and branches.

		The algorithm has three steps:

			1. Generate a reachability graph for labels
				This will generate a graph of all labels, with edges pointing to
				all reachable parents. Unfortunately this may possibly include
				edges from labels to parents that are also parents of the
				label's parents. These edges are redundant and must be removed.

			2. Generate a full parent graph for labels
				This will use the information from step 1. to generate a graph
				of labels, with edges pointing to all parents, where in this
				case the parent of a parent of a label is also that label's
				parent.

			3. Generate the reduced commit graph containing tags and branches
				This will use the information from step 2. to prune the edges of
				the full parent graph and produce the final output graph
		"""
		def recurse(commit, in_labeled_parents, out_seen_commits):
			""" Recursive call used in step 2. """
			all_parents = set()
			if commit in out_seen_commits.keys():
				# we have already explored the parents
				all_parents = out_seen_commits[commit].copy()
			elif len(in_labeled_parents[commit]) == 0:
				# there are no parents
				out_seen_commits[commit] = all_parents.copy()
			else:
				# explore the commits before this one
				for p in in_labeled_parents[commit]:
					all_parents = all_parents.union(
						recurse(p, in_labeled_parents, out_seen_commits))
				# record what we have seen
				out_seen_commits[commit] = all_parents.copy()
			# add the current commit to the list of parents
			# and return from recursive step
			all_parents.add(commit)
			return all_parents

		# 1. Generate a reachability graph for labels
		reachable_labeled_parents = dict()
		for label in self.branches.keys() + self.tags.keys():
			to_visit = list(self.parents[label])
			seen = set()
			reachable_labeled_parents[label] = set()
			for commit in to_visit:
				if commit in seen:
					continue
				else:
					seen.add(commit)
					if self._has_label(commit):
						# has label and is reachable from current label
						reachable_labeled_parents[label].add(commit)
					else:
						# no label, continue searching
						to_visit.extend(self.parents[commit])

		# 2. Generate a full parent graph for labels
		seen_commits = dict()
		for label in self.branches.keys() + self.tags.keys():
			recurse(label, reachable_labeled_parents, seen_commits)

		# 3. Generate the reduced commit graph containing tags and branches
		for label in seen_commits.keys():
			# get the parents of the parents of label, and if these are also
			# parents of label, remove them from label's parent list
			for parent in seen_commits[label].copy():
				for p_parent in seen_commits[parent]:
					if p_parent in seen_commits[label]:
						seen_commits[label].remove(p_parent)

		self.parents = seen_commits
		self._calculate_child_mapping()

	def _generate_dot_file(self):
		def label_gen():
			keys = set(self.branches.keys()).union(set(self.tags.keys()))
			for k in keys:
				labels = []
				case = 0
				if k in self.tags:
					case = case + 1
					map(labels.append, sorted(self.tags[k]))
				if k in self.branches:
					case = case + 2
					map(labels.append, sorted(self.branches[k]))
				# http://www.graphviz.org/doc/info/colors.html
				color = "/pastel13/%d" % case
				yield (k, labels, color)
					
		dot_file_lines = ['digraph {']
		for sha_one, labels, color in label_gen():
			dot_file_lines.append('\t"%(ref)s"[label="%(label)s", color="%(color)s", style=filled];' % {
				'ref':sha_one,
				'label':'\\n'.join(labels),
				'color':color})
		for child, self.parents in self.parents.items():
			for p in self.parents:
				dot_file_lines.append('\t"%(source)s" -> "%(target)s";' % {'source':child, 'target':p})
		dot_file_lines.append('}')
		return dot_file_lines


if True:  # Hack to save our VCS diffs from indentation changes
	def _process_dot_output(dot_file_lines, format = None, viewer = None, outfile = None):
		import tempfile, os, sys
		if not format:
			if outfile:
				format = outfile.split('.')[-1]
				sys.stderr.write('guessing format: %s.\n' % format)
			else: # output plain text
				for line in dot_file_lines:
					print line
				return 0
		# output in specified format
		try:
			p = subprocess.Popen(['dot', '-T'+format], stdin=subprocess.PIPE,
				stdout=subprocess.PIPE, stderr=subprocess.PIPE)
		except OSError, e:
			if e.errno == 2:
				sys.stderr.write('Fatal: `dot\' not found! Please install the Graphviz utility.\n')
			else:
				sys.stderr.write('Fatal: A problem occured calling `dot -T' + format + '\'!\n')
			sys.exit(2)
		if p.poll():
			sys.stderr.write('`dot\' terminated prematurely with error code %d;\n'
				'probably you specified an invalid format, see "man dot"\n' % p.poll())
			sys.exit(3)
		# send dot input, automatically receive and store output
		dot_output = p.communicate(input='\n'.join(dot_file_lines))[0]
		if viewer or outfile:
			if outfile:
				try:
					f = open(outfile, 'w+b')
				except IOError, e:
					sys.stderr.write('Fatal: could not open file %s (errno: %d)!\n' % (outfile, e.errno))
					sys.exit(4)
			elif viewer:
				f = tempfile.NamedTemporaryFile(prefix='git-big-picture')
			f.write(dot_output)
			f.flush()
			os.fsync(f.fileno())
			if viewer:
				try:
					subprocess.call([viewer, f.name])
				except OSError, e:
					sys.stderr.write('Error calling `' + viewer + '\'!')
					sys.exit(5)
			f.close() # tmpfile is automatically deleted
		else: # print raw SVG, PDF, ...
			print dot_output


if __name__ == '__main__':
	from optparse import OptionParser
	parser = OptionParser(usage='usage: %prog [-f <format> [-v <viewer>]] [<.git-directory>]', version=VERSION)
	parser.add_option('-f', '--format', action='store', type='string', dest='format',
		metavar='FMT', help='set output format [svg, png, ps, pdf, ...]')
	parser.add_option('-o', '--out', action='store', type='string', dest='outfile',
		metavar='FILE', help='write image to specified file')
	parser.add_option('-v', '--viewer', action='store', type='string', dest='viewer',
		metavar='CMD', help='write image to tempfile and start specified viewer')
	opts, args = parser.parse_args()
	if len(args) == 1:
		# check whether the argument is a valid git directory
		p = subprocess.Popen(['git', 'rev-parse', '--git-dir'],
			stdout=subprocess.PIPE, stderr=subprocess.PIPE, env={'GIT_DIR': args[0]})
		p.wait()
		if p.returncode:
			import sys
			sys.stderr.write('Fatal: Does not appear to be a .git directory: %s.\n' % args[0])
			sys.exit(1)
		else:
			git_env = {'GIT_DIR': args[0]}
	graph = CommitGraph(get_parent_map(), get_branch_dict(), get_tag_dict())
	# graph._optimize_linear_runs_away()
	# graph._optimize_merge_branch_fits_away()
	# graph._optimize_non_labels()
	graph._remove_non_labels()
	dot_file_lines = graph._generate_dot_file()
	_process_dot_output(dot_file_lines, format=opts.format, viewer=opts.viewer, outfile=opts.outfile)

# vim: set noexpandtab:
